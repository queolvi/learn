 **1**  | –°–∏–Ω—Ç–∞–∫—Å–∏—Å C++11: `auto`, `lambda`, `nullptr` | –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –∞–Ω–∞–ª–æ–≥–∞ `std::vector` 

7/06/25

................................................................................................

auto
{
1) "–í –æ—Å–Ω–æ–≤–Ω–æ–º —ç—Ç–æ –ª—è–º–±–¥–∞-—Ñ—É–Ω–∫—Ü–∏–∏, range based for, auto &[x, y, ...] = ..., –∏—Ç–µ—Ä–∞—Ç–æ—Ä—ã –∏ –ø—Ä–æ—á–∏–µ —Å–ª–æ–∂–Ω—ã–µ —Ç–∏–ø—ã"
2) —â–∞—Å –ø—Ä–æ–±—É—é –ø—Ä–∏–º–µ—Ä –Ω–∞–ø–∏—Å–∞—Ç—å
3) loop with auto
4) 
auto x = 42;         // int
auto y = 3.14;       // double
auto z = "hello";    // const char*
auto w = 'a';        // char;
5) 
std::vector<int> vec = {1,2,3,4,5,6};

before c++ 11: 
for(std::vector<int> iterator it_ = vec.begin(); it_ != vec.end(); ++it_) {....}

with c++ and go next standart ver:
for(auto it_ = vec.begin(); it_ != vec.end(); ++it_) {....}
6) 
range based (–Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞) for with c++ 11 and next go:

for(auto v : vec_) {...} // v - is copy
for(const auto& v : vec) {...} // v - is ref without copy;

7)
1: 
c++ 14 upgrades:
auto can return!
auto add_(int a, int b) {
    auto res = a + b;
    return res;
}

2:
lambdas with parameters:
what is lambda?
lambda = this is mini functional class
auto sum_a_b { [](auto a, auto b) { auto res = a + b; return res; } }
and when compiler meet lambda expression, he made a empty-field class with one " operator()() const {}" 
, which type is auto 
auto lambda = [](auto x, auto y) {auto res = x + y;  return res; }

8)
additions on c++17
–≤—ã–≤–æ–¥ —Ç–∏–ø–æ–≤ –≤ —à–∞–±–ª–æ–Ω–Ω—ã—Ö –∫–ª–∞—Å—Å–∞—Ö

std::pair<int, double> p1{1, 2.0};  // –î–æ C++17
auto p2 = std::make_pair(1, 2.0);   // –î–æ C++17 (–Ω–æ –ª—É—á—à–µ auto)
auto p3 = std::pair(1, 2.0);        // C++17 (–∞–≤—Ç–æ–≤—ã–≤–æ–¥ —Ç–∏–ø–æ–≤)
—Ç—É—Ç –≤—Å—ë —è—Å–Ω–æ

structured blinding (—Å—Ç—Ä—É–∫—Ç—É—Ä–Ω–æ–µ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ)
std::map <int, std::string> m = {{1, "one"}, {2, "two"}};

9)

–≥–¥–µ –ø–æ–ª–µ–∑–µ–Ω?
1) –≤ —Ü–∏–∫–ª–∞—Ö –∏ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∞—Ö

for(auto ti_ = container.begin(); it_ != container.end(); ++it) {...}
for(const auto& el : container) {...}

–∫–∞–∫ –Ω–µ –Ω–∞–¥–æ:
for(std::vector<myLongTypeName>::iterator it = ... ) {...}
—ç—Ç–æ —Å–ª–∏—à–∫–æ–º –∏–∑–±—ã—Ç–æ—á–Ω–æ!

2) –∫–æ–≥–¥–∞ —Ç–∏–ø –æ—á–µ–≤–∏–¥–µ–Ω –∏–∑ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ç–æ—Ä–∞:
auto x = 42;       // int
auto name = "Bob"; // const char*
auto p = getPointer();  // –ï—Å–ª–∏ —Ç–∏–ø getPointer() –æ—á–µ–≤–∏–¥–µ–Ω

–∫–æ–≥–¥–∞ –ø–ª–æ—Ö–æ:
auto x = getUserInput(); // —ç—Ç–æ –∫–æ–≥–¥–∞ —Ç–∏–ø –Ω–µ –æ—á–µ–≤–∏–¥–µ–Ω

3) –î–ª—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö —Å –∫–æ—Ä–æ—Ç–∫–∏–º –∂–∏–∑–Ω–µ–Ω–Ω—ã–º —Ü–∏–∫–ª–æ–º
void process() {
    auto rhs = calc_val(); - –∂–∏–≤—ë—Ç —Ç–æ–ª—å–∫–æ –≤ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏
    // ..
}

–≥–¥–µ —ç—Ç–æ –ø–ª–æ—Ö–æ: 
auto global_var = getData(); // –Ω–µ–ª—å–∑—è –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —Å —Ç–∏–ø–æ–º auto

4) –≥–¥–µ —ç—Ç–æ –Ø–í–ù–û –≤—Ä–µ–¥–Ω–æ?
1. –∫–æ–≥–¥–∞ —Ç–∏–ø –≤–∞–∂–µ–Ω –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏!
auto res = process(); // —á—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç res? int? bool?
2. –ü—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å –ø—Ä–æ–∫—Å–∏-–æ–±—ä–µ–∫—Ç–∞–º–∏:
std::vector<bool> vec = {true, false};
auto x = vec[0]; // x - –Ω–µ bool, –∞ std::vector<bool>::reference!
---- –Ω—É–∂–Ω–æ —è–≤–Ω–æ —É–∫–∞–∑–∞—Ç—å bool x = vec[0] / static_cast<>;
3. –í –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞—Ö —Ñ—É–Ω–∫—Ü–∏–π
auto get_data() { return complexType(); } // –ª—É—á—à–µ —è–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞—Ç—å —Ç–∏–ø, –∫–æ—Ç–æ—Ä—ã–π –Ω—É–∂–µ–Ω –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è

–≤—ã–≤–æ–¥:
—Å–∏—Ç—É–∞—Ü–∏—è                ||          —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
–∏—Ç–µ—Ä–∞—Ç–æ—Ä—ã - —Ü–∏–∫–ª—ã                   yes (—É–ø—Ä–æ—â–∞–µ—Ç –∫–æ–¥)
–æ—á–µ–≤–∏–¥–Ω—ã–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ç–æ—Ä—ã            yes { auto x = 42; } 
–ª—è–º–±–¥—ã - –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–µ —Ç–∏–ø—ã(—Å++14)   yes { auto }
—Å—Ç—Ä—É–∫—Ç—É—Ä–Ω–æ–µ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ              yes { auto [key, val] = ... }
–Ω–µ–æ—á–µ–≤–∏–¥–Ω—ã–µ —Ç–∏–ø—ã                    no recommended { –ª—É—á—à–µ —è–≤–Ω–æ }


...........................................................................................


lambda  
{
1. –õ—è–º–±–¥—ã –≤ C++11 (–±–∞–∑–æ–≤—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å)
1.1 –ë–∞–∑–æ–≤–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –ª—è–º–±–¥—ã
cpp
[–∑–∞—Ö–≤–∞—Ç](–ø–∞—Ä–∞–º–µ—Ç—Ä—ã) -> –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–π_—Ç–∏–ø { —Ç–µ–ª–æ }
–ü—Ä–∏–º–µ—Ä:

cpp
auto sum = [](int a, int b) -> int { return a + b; };
std::cout << sum(2, 3); // 5
–ï—Å–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–π —Ç–∏–ø –º–æ–∂–Ω–æ –≤—ã–≤–µ—Å—Ç–∏, –µ–≥–æ –º–æ–∂–Ω–æ –æ–ø—É—Å—Ç–∏—Ç—å:

cpp
auto sum = [](int a, int b) { return a + b; }; // -> int –≤—ã–≤–µ–¥–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
1.2 –ó–∞—Ö–≤–∞—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö (capture)
–õ—è–º–±–¥–∞ –º–æ–∂–µ—Ç "–∑–∞—Ö–≤–∞—Ç—ã–≤–∞—Ç—å" –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ –æ–∫—Ä—É–∂–∞—é—â–µ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏:

[ ] ‚Äî –Ω–∏—á–µ–≥–æ –Ω–µ –∑–∞—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç.

[=] ‚Äî –∑–∞—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç –≤—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é.

[&] ‚Äî –∑–∞—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç –≤—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –ø–æ —Å—Å—ã–ª–∫–µ.

[x, &y] ‚Äî –∑–∞—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç x –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é, y –ø–æ —Å—Å—ã–ª–∫–µ.

–ü—Ä–∏–º–µ—Ä:

cpp
int x = 10, y = 20;
auto lambda = [x, &y]() { 
    y = x + y;  // x - –∫–æ–ø–∏—è, y - —Å—Å—ã–ª–∫–∞ (–∏–∑–º–µ–Ω—è–µ—Ç—Å—è –æ—Ä–∏–≥–∏–Ω–∞–ª)
};
lambda();
std::cout << y; // 30
1.3 –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ –∞–ª–≥–æ—Ä–∏—Ç–º–∞—Ö
–õ—è–º–±–¥—ã —á–∞—Å—Ç–æ –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è —Å <algorithm>:

cpp
std::vector<int> v = {1, 2, 3, 4, 5};
// –£–º–Ω–æ–∂–∏—Ç—å –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç –Ω–∞ 2
std::transform(v.begin(), v.end(), v.begin(), [](int x) { return x * 2; });
2. –£–ª—É—á—à–µ–Ω–∏—è –≤ C++14
2.1 –û–±–æ–±—â—ë–Ω–Ω—ã–µ –ª—è–º–±–¥—ã (auto –≤ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞—Ö)
–†–∞–Ω—å—à–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ª—è–º–±–¥ –¥–æ–ª–∂–Ω—ã –±—ã–ª–∏ –∏–º–µ—Ç—å —è–≤–Ω—ã–π —Ç–∏–ø. –í C++14 –ø–æ—è–≤–∏–ª—Å—è auto:

cpp
// C++11: –Ω—É–∂–Ω–æ —è–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞—Ç—å —Ç–∏–ø
auto addInt = [](int a, int b) { return a + b; };

// C++14: auto-–ø–∞—Ä–∞–º–µ—Ç—Ä—ã (—Ä–∞–±–æ—Ç–∞–µ—Ç –∫–∞–∫ —à–∞–±–ª–æ–Ω)
auto add = [](auto a, auto b) { return a + b; };
std::cout << add(2, 3);    // 5
std::cout << add(2.5, 3.1); // 5.6
2.2 –ó–∞—Ö–≤–∞—Ç —Å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–µ–π
–ú–æ–∂–Ω–æ —Å–æ–∑–¥–∞–≤–∞—Ç—å –Ω–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –ø—Ä—è–º–æ –≤ –∑–∞—Ö–≤–∞—Ç–µ:

cpp
int x = 10;
auto lambda = [y = x + 5]() { return y; }; // y = 15
–≠—Ç–æ –æ—Å–æ–±–µ–Ω–Ω–æ –ø–æ–ª–µ–∑–Ω–æ –¥–ª—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è (move) –æ–±—ä–µ–∫—Ç–æ–≤:

cpp
auto ptr = std::make_unique<int>(42);
auto lambda = [p = std::move(ptr)]() { return *p; }; // –ó–∞—Ö–≤–∞—Ç —Å –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ–º
3. –î–æ–ø–æ–ª–Ω–µ–Ω–∏—è –≤ C++17 –∏ C++20
3.1 constexpr –ª—è–º–±–¥—ã (C++17)
–õ—è–º–±–¥—ã –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ compile-time –≤—ã—á–∏—Å–ª–µ–Ω–∏—è—Ö:

cpp
constexpr auto square = [](int x) { return x * x; };
static_assert(square(5) == 25); // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
3.2 –®–∞–±–ª–æ–Ω–Ω—ã–µ –ª—è–º–±–¥—ã —Å template (C++20)
–ï—Å–ª–∏ auto –≤ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞—Ö –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ, –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —è–≤–Ω—ã–µ —à–∞–±–ª–æ–Ω—ã:

cpp
auto print = []<typename T>(const T& val) { 
    std::cout << val << std::endl; 
};
print(42);       // int
print("hello");  // const char*
3.3 –ó–∞—Ö–≤–∞—Ç [*this] (C++17)
–†–∞–Ω—å—à–µ [=] –∑–∞—Ö–≤–∞—Ç—ã–≤–∞–ª this –∫–∞–∫ —É–∫–∞–∑–∞—Ç–µ–ª—å, —á—Ç–æ –º–æ–≥–ª–æ –ø—Ä–∏–≤–æ–¥–∏—Ç—å –∫ dangling reference. –í C++17 –º–æ–∂–Ω–æ –∑–∞—Ö–≤–∞—Ç–∏—Ç—å –∫–æ–ø–∏—é –æ–±—ä–µ–∫—Ç–∞:

cpp
struct MyStruct {
    int value = 42;
    auto getLambda() {
        return [*this]() { return value; }; // –ö–æ–ø–∏—Ä—É–µ—Ç *this, –∞ –Ω–µ this
    }
};
4. –û—Å–Ω–æ–≤–Ω—ã–µ –∫–µ–π—Å—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
4.1 –ê–ª–≥–æ—Ä–∏—Ç–º—ã STL (sort, find_if, for_each...)
cpp
std::vector<int> nums = {3, 1, 4, 1, 5, 9};
// –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —É–±—ã–≤–∞–Ω–∏—é
std::sort(nums.begin(), nums.end(), [](int a, int b) { return a > b; });

// –ü–æ–∏—Å–∫ –ø–µ—Ä–≤–æ–≥–æ —á—ë—Ç–Ω–æ–≥–æ —á–∏—Å–ª–∞
auto it = std::find_if(nums.begin(), nums.end(), [](int x) { return x % 2 == 0; });
4.2 –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏ –∏ callback'–∏
cpp
void fetchData(std::function<void(std::string)> callback) {
    // ... –∑–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö ...
    callback("Data received!");
}

fetchData([](const std::string& msg) { 
    std::cout << msg << std::endl; 
});
4.3 –°–æ–∑–¥–∞–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –Ω–∞ –ª–µ—Ç—É
cpp
auto makeMultiplier = [](int factor) {
    return [factor](int x) { return x * factor; };
};

auto doubleIt = makeMultiplier(2);
std::cout << doubleIt(5); // 10
5. –ö–æ–≥–¥–∞ –ª—è–º–±–¥—ã –≤—Ä–µ–¥–Ω—ã (–∞–Ω—Ç–∏–ø–∞—Ç—Ç–µ—Ä–Ω—ã)
–°–ª–∏—à–∫–æ–º —Å–ª–æ–∂–Ω—ã–µ –ª—è–º–±–¥—ã
–ï—Å–ª–∏ —Ç–µ–ª–æ –ª—è–º–±–¥—ã –±–æ–ª—å—à–µ 5-10 —Å—Ç—Ä–æ–∫ ‚Äî –ª—É—á—à–µ –≤—ã–Ω–µ—Å—Ç–∏ –≤ –æ—Ç–¥–µ–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é.

–ó–∞—Ö–≤–∞—Ç –ø–æ —Å—Å—ã–ª–∫–µ —Å –æ–ø–∞—Å–Ω—ã–º –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏

cpp
std::function<void()> createLambda() {
    int x = 10;
    return [&x]() { std::cout << x; }; // UB: x —É–º—Ä—ë—Ç –ø–æ—Å–ª–µ –≤—ã—Ö–æ–¥–∞ –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏!
}
‚Üí –õ—É—á—à–µ –∑–∞—Ö–≤–∞—Ç—ã–≤–∞—Ç—å –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é ([x]) –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å [=].

–ò–∑–±—ã—Ç–æ—á–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ [&] –∏–ª–∏ [=]
–ó–∞—Ö–≤–∞—Ç –≤—Å–µ—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –º–æ–∂–µ—Ç –ø—Ä–∏–≤–æ–¥–∏—Ç—å –∫ –Ω–µ–æ—á–µ–≤–∏–¥–Ω—ã–º –æ—à–∏–±–∫–∞–º. –õ—É—á—à–µ —è–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞—Ç—å, —á—Ç–æ –∑–∞—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç—Å—è.

–í—ã–≤–æ–¥
–°–∏—Ç—É–∞—Ü–∏—è	                           ||     –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è
–ö–æ—Ä–æ—Ç–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤ –∞–ª–≥–æ—Ä–∏—Ç–º–∞—Ö	       ||     ‚úÖ –õ—è–º–±–¥–∞ (sort, find_if, ...)
Callback'–∏ –∏ –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏	       ||     ‚úÖ –õ—è–º–±–¥–∞ + std::function
–ó–∞–º—ã–∫–∞–Ω–∏—è —Å –ª–æ–∫–∞–ª—å–Ω—ã–º–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º–∏	   ||     ‚úÖ –ó–∞—Ö–≤–∞—Ç ([x], [&y], [=])
–®–∞–±–ª–æ–Ω–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ (C++14+)	           ||    ‚úÖ auto-–ø–∞—Ä–∞–º–µ—Ç—Ä—ã
–°–ª–æ–∂–Ω–∞—è –ª–æ–≥–∏–∫–∞ (>10 —Å—Ç—Ä–æ–∫)	           ||     üö´ –õ—É—á—à–µ –æ—Ç–¥–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è

}


........................................................................................


nullptr 
{







}

